# Knowledge Capture

Conditionally loaded when processing sub-agent responses to extract KNOWLEDGE markers.

## KNOWLEDGE Marker Format

Sub-agents emit knowledge markers when discovering insights worth preserving:

```
KNOWLEDGE: {"title": "Brief descriptive title", "summary": "Detailed explanation of the insight, solution, or workaround", "keywords": ["keyword1", "keyword2", "keyword3"]}
```

**Requirements:**
- JSON must be on a single line following the `KNOWLEDGE:` prefix
- Title: 5-10 words, descriptive, starts with action verb or noun
- Summary: 50-200 words, explains the problem, solution, and why it matters
- Keywords: 3-7 lowercase terms for searchability

## When to Emit KNOWLEDGE Markers

Emit markers when:

1. **Solving non-obvious problems** - The solution required investigation or multiple attempts
2. **Working around edge cases** - Discovered unexpected behavior or limitations
3. **Making tradeoff decisions** - Chose between alternatives with clear rationale
4. **Discovering unexpected behavior** - Found something that contradicts assumptions
5. **Integrating unfamiliar APIs** - Learned how to use an external service or library

## What NOT to Emit

Do not emit markers for:
- Routine implementation (adding CRUD operations, basic components)
- Trivial fixes (typos, missing imports, obvious syntax errors)
- Standard patterns documented elsewhere
- Personal preferences without technical justification

## Keyword Extraction Guidance

Good keywords are:
- Lowercase and specific (e.g., "typescript", "async-await", "null-check")
- Technology names (e.g., "react", "postgresql", "docker")
- Pattern names (e.g., "retry-logic", "circuit-breaker", "dependency-injection")
- Problem domains (e.g., "authentication", "caching", "rate-limiting")

Avoid:
- Generic terms ("code", "fix", "problem", "solution")
- Full phrases ("how to fix", "when you need")
- Proper nouns unless they are technologies

## Example Entries

### Good Example 1: Edge Case Discovery

```
KNOWLEDGE: {"title": "PostgreSQL JSON array contains requires cast", "summary": "When querying PostgreSQL JSONB arrays with the @> operator, string values must be explicitly cast. The query `WHERE tags @> '\"value\"'` fails silently. Use `WHERE tags @> '\"value\"'::jsonb` instead. This applies to all JSONB containment checks with string literals.", "keywords": ["postgresql", "jsonb", "containment-operator", "type-casting"]}
```

### Good Example 2: Workaround

```
KNOWLEDGE: {"title": "Jest mock timer workaround for async hooks", "summary": "Jest fake timers break useEffect cleanup with async operations. The workaround is to wrap act() calls with runOnlyPendingTimers before unmount. Call jest.runOnlyPendingTimers() inside act() before component cleanup to flush pending timers.", "keywords": ["jest", "fake-timers", "react-testing", "useeffect", "async"]}
```

### Good Example 3: Tradeoff Decision

```
KNOWLEDGE: {"title": "Chose debounce over throttle for search input", "summary": "For search-as-you-type, debounce (300ms) provides better UX than throttle. Throttle fires immediately then limits, causing premature searches. Debounce waits for typing pause, reducing API calls by 60% in testing. Use lodash.debounce with leading:false, trailing:true.", "keywords": ["debounce", "throttle", "search", "performance", "user-input"]}
```

## Processing KNOWLEDGE Markers

When extracting KNOWLEDGE markers from sub-agent response:

1. **Parse JSON payload** - Extract title, summary, keywords from JSON
2. **Validate structure** - Ensure required fields present
3. **Generate entry ID** - Read `.tiki/knowledge/index.json`, get nextId, format as K001, K002, etc.
4. **Create entry file** - Write to `.tiki/knowledge/entries/{id}-{slug}.md`
5. **Update index** - Add entry metadata to index.json

### Entry File Format

```markdown
# {title}

**ID:** {id}
**Created:** {ISO timestamp}
**Source:** Issue #{issueNumber}, Phase {phaseNumber}
**Keywords:** {comma-separated keywords}

---

{summary}

---

*Auto-generated during execution*
```

### Index Update

Add to entries array in `.tiki/knowledge/index.json`:

```json
{
  "id": "K001",
  "title": "...",
  "keywords": [...],
  "source": {
    "type": "execution",
    "issueRef": 42,
    "phase": 3
  },
  "autoGenerated": true,
  "createdAt": "...",
  "status": "active"
}
```

Increment `nextId` after creating entry.
